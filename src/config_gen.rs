
use crate::discovery::{find_source_files_with_ignore, Language};
use crate::graph::build_dependency_graph;
use crate::parsing::{parse_files, ParsedFile};
use crate::rust_graph::build_rust_dependency_graph;
use crate::rust_parsing::{parse_rust_files, ParsedRustFile};
use crate::stats::{compute_summaries, MetricStats, PercentileSummary};
use std::path::Path;

pub fn collect_py_stats(root: &Path) -> (MetricStats, usize) {
    collect_py_stats_with_ignore(root, &[])
}

pub fn collect_py_stats_with_ignore(root: &Path, ignore: &[String]) -> (MetricStats, usize) {
    let py_files: Vec<_> = find_source_files_with_ignore(root, ignore)
        .into_iter()
        .filter(|sf| sf.language == Language::Python)
        .map(|sf| sf.path)
        .collect();
    if py_files.is_empty() { return (MetricStats::default(), 0); }
    let Ok(results) = parse_files(&py_files) else { return (MetricStats::default(), 0); };
    let parsed: Vec<ParsedFile> = results.into_iter().filter_map(std::result::Result::ok).collect();
    let cnt = parsed.len();
    let refs: Vec<&ParsedFile> = parsed.iter().collect();
    let mut stats = MetricStats::collect(&refs);
    stats.collect_graph_metrics(&build_dependency_graph(&refs));
    (stats, cnt)
}

pub fn collect_rs_stats(root: &Path) -> (MetricStats, usize) {
    collect_rs_stats_with_ignore(root, &[])
}

pub fn collect_rs_stats_with_ignore(root: &Path, ignore: &[String]) -> (MetricStats, usize) {
    let rs_files: Vec<_> = find_source_files_with_ignore(root, ignore)
        .into_iter()
        .filter(|sf| sf.language == Language::Rust)
        .map(|sf| sf.path)
        .collect();
    if rs_files.is_empty() { return (MetricStats::default(), 0); }
    let parsed: Vec<ParsedRustFile> = parse_rust_files(&rs_files).into_iter().filter_map(std::result::Result::ok).collect();
    let cnt = parsed.len();
    let refs: Vec<&ParsedRustFile> = parsed.iter().collect();
    let mut stats = MetricStats::collect_rust(&refs);
    stats.collect_graph_metrics(&build_rust_dependency_graph(&refs));
    (stats, cnt)
}

pub fn collect_all_stats(paths: &[String], lang: Option<Language>) -> ((MetricStats, usize), (MetricStats, usize)) {
    collect_all_stats_with_ignore(paths, lang, &[])
}

pub fn collect_all_stats_with_ignore(paths: &[String], lang: Option<Language>, ignore: &[String]) -> ((MetricStats, usize), (MetricStats, usize)) {
    let (mut py, mut rs) = ((MetricStats::default(), 0), (MetricStats::default(), 0));
    for path in paths {
        let root = Path::new(path);
        if lang.is_none() || lang == Some(Language::Python) { 
            let (s, c) = collect_py_stats_with_ignore(root, ignore); 
            py.0.merge(s); 
            py.1 += c; 
        }
        if lang.is_none() || lang == Some(Language::Rust) { 
            let (s, c) = collect_rs_stats_with_ignore(root, ignore); 
            rs.0.merge(s); 
            rs.1 += c; 
        }
    }
    (py, rs)
}

pub fn write_mimic_config(out: &Path, toml: &str, py_cnt: usize, rs_cnt: usize) {
    let content = if out.exists() { 
        merge_config_toml(out, toml, py_cnt > 0, rs_cnt > 0) 
    } else { 
        toml.to_string() 
    };
    if let Err(e) = std::fs::write(out, &content) { 
        eprintln!("Error writing to {}: {}", out.display(), e); 
        std::process::exit(1); 
    }
    eprintln!("Generated config from {} files â†’ {}", py_cnt + rs_cnt, out.display());
}

fn format_section(out: &mut String, name: &str, section: Option<&toml::Value>) {
    use std::fmt::Write;
    if let Some(v) = section {
        let _ = writeln!(out, "[{name}]");
        if let Some(t) = v.as_table() { 
            for (k, v) in t { 
                let _ = writeln!(out, "{k} = {v}"); 
            } 
        }
        out.push('\n');
    }
}

pub fn merge_config_toml(path: &Path, new: &str, upd_py: bool, upd_rs: bool) -> String {
    let (Ok(ex_str), Ok(nw)) = (std::fs::read_to_string(path), new.parse::<toml::Table>()) else { 
        return new.to_string(); 
    };
    let Ok(ex) = ex_str.parse::<toml::Table>() else { return new.to_string(); };
    let pick = |k: &str, upd: bool| if upd { nw.get(k) } else { ex.get(k) }.cloned();
    let mut m = toml::Table::new();
    for (k, upd) in [("python", upd_py), ("rust", upd_rs)] { 
        if let Some(v) = pick(k, upd) { m.insert(k.to_string(), v); } 
    }
    let shared = if upd_py && upd_rs { nw.get("shared") } else { ex.get("shared").or_else(|| nw.get("shared")) }.cloned();
    if let Some(v) = shared { m.insert("shared".to_string(), v); }
    if !(upd_py && upd_rs) && let Some(v) = ex.get("thresholds").cloned() { 
        m.insert("thresholds".to_string(), v); 
    }
    build_merged_output(&m)
}

fn build_merged_output(m: &toml::Table) -> String {
    let mut out = String::from("# Generated by kiss mimic\n# Thresholds based on 99th percentile of analyzed codebases\n\n");
    for k in ["python", "rust", "shared", "thresholds"] { 
        format_section(&mut out, k, m.get(k)); 
    }
    out
}

pub fn generate_config_toml_by_language(py: &MetricStats, rs: &MetricStats, py_n: usize, rs_n: usize) -> String {
    let mut out = String::from("# Generated by kiss mimic\n# Thresholds based on 99th percentile of analyzed codebases\n\n");
    if py_n > 0 { append_section(&mut out, "[python]", &compute_summaries(py), python_config_key); }
    if rs_n > 0 { append_section(&mut out, "[rust]", &compute_summaries(rs), rust_config_key); }
    if py_n > 0 && rs_n > 0 { append_shared_section(&mut out, &compute_summaries(py), &compute_summaries(rs)); }
    out
}

fn append_section(out: &mut String, header: &str, sums: &[PercentileSummary], key_fn: fn(&str) -> Option<&'static str>) {
    use std::fmt::Write;
    out.push_str(header); 
    out.push('\n');
    for s in sums { 
        if let Some(k) = key_fn(s.name) { 
            let _ = writeln!(out, "{k} = {}", s.p99); 
        } 
    }
    out.push('\n');
}

fn append_shared_section(out: &mut String, py_sums: &[PercentileSummary], rs_sums: &[PercentileSummary]) {
    use std::fmt::Write;
    out.push_str("[shared]\n");
    for py_s in py_sums {
        if let Some(k) = shared_config_key(py_s.name) {
            let rs_val = rs_sums.iter().find(|s| s.name == py_s.name).map_or(0, |s| s.p99);
            let _ = writeln!(out, "{k} = {}", py_s.p99.max(rs_val));
        }
    }
}

pub fn python_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Statements per function" => Some("statements_per_function"),
        "Arguments (positional)" => Some("positional_args"),
        "Arguments (keyword-only)" => Some("keyword_only_args"),
        "Max indentation depth" => Some("max_indentation"),
        "Branches per function" => Some("branches_per_function"),
        "Local variables per function" => Some("local_variables"),
        "Methods per class" => Some("methods_per_class"),
        _ => None,
    }
}

pub fn rust_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Statements per function" => Some("statements_per_function"),
        "Arguments (total)" => Some("arguments"),
        "Max indentation depth" => Some("max_indentation"),
        "Branches per function" => Some("branches_per_function"),
        "Local variables per function" => Some("local_variables"),
        "Methods per class" => Some("methods_per_class"),
        _ => None,
    }
}

pub fn shared_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Statements per file" => Some("statements_per_file"),
        "Classes per file" => Some("types_per_file"),
        "Imported names per file" => Some("imported_names_per_file"),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_collection() {
        let tmp = TempDir::new().unwrap();
        assert_eq!(collect_py_stats(tmp.path()).1, 0);
        assert_eq!(collect_rs_stats(tmp.path()).1, 0);
        let paths = vec![tmp.path().to_string_lossy().to_string()];
        assert_eq!(collect_all_stats(&paths, None).0.1, 0);
        assert_eq!(collect_py_stats_with_ignore(tmp.path(), &["fake_".into()]).1, 0);
        assert_eq!(collect_rs_stats_with_ignore(tmp.path(), &["fake_".into()]).1, 0);
        assert_eq!(collect_all_stats_with_ignore(&paths, None, &["fake_".into()]).0.1, 0);
    }

    #[test]
    fn test_config_keys_and_generation() {
        assert_eq!(python_config_key("Statements per function"), Some("statements_per_function"));
        assert_eq!(rust_config_key("Statements per function"), Some("statements_per_function"));
        assert_eq!(shared_config_key("Statements per file"), Some("statements_per_file"));
        assert!(generate_config_toml_by_language(&MetricStats::default(), &MetricStats::default(), 0, 0).contains("Generated by kiss"));
        assert!(build_merged_output(&toml::Table::new()).contains("Generated by kiss"));
        let mut out = String::new();
        let mut table = toml::Table::new();
        table.insert("key".into(), toml::Value::Integer(42));
        format_section(&mut out, "test", Some(&toml::Value::Table(table)));
        assert!(out.contains("[test]") && out.contains("key = 42"));
        let mut out2 = String::new();
        append_section(&mut out2, "[python]", &[PercentileSummary { name: "Statements per function", count: 10, max: 50, p50: 5, p90: 10, p95: 15, p99: 20 }], python_config_key);
        assert!(out2.contains("statements_per_function = 20"));
        let mut out3 = String::new();
        append_shared_section(&mut out3, &[PercentileSummary { name: "Statements per file", count: 5, max: 500, p50: 100, p90: 200, p95: 250, p99: 300 }], &[PercentileSummary { name: "Statements per file", count: 5, max: 600, p50: 150, p90: 250, p95: 350, p99: 400 }]);
        assert!(out3.contains("statements_per_file = 400"));
    }
}

