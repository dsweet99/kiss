//! Configuration generation for the mimic command
//!
//! This module handles generating TOML configuration files from analyzed codebases.

use crate::discovery::Language;
use crate::graph::build_dependency_graph;
use crate::parsing::{parse_files, ParsedFile};
use crate::rust_parsing::{parse_rust_files, ParsedRustFile};
use crate::stats::{compute_summaries, MetricStats, PercentileSummary};
use crate::{find_python_files, find_rust_files};
use std::path::Path;

/// Collect Python statistics from a directory
pub fn collect_py_stats(root: &Path) -> (MetricStats, usize) {
    let py_files = find_python_files(root);
    if py_files.is_empty() { return (MetricStats::default(), 0); }
    let Ok(results) = parse_files(&py_files) else { return (MetricStats::default(), 0); };
    let parsed: Vec<ParsedFile> = results.into_iter().filter_map(|r| r.ok()).collect();
    let cnt = parsed.len();
    let refs: Vec<&ParsedFile> = parsed.iter().collect();
    let mut stats = MetricStats::collect(&refs);
    stats.collect_graph_metrics(&build_dependency_graph(&refs));
    (stats, cnt)
}

/// Collect Rust statistics from a directory
pub fn collect_rs_stats(root: &Path) -> (MetricStats, usize) {
    let rs_files = find_rust_files(root);
    if rs_files.is_empty() { return (MetricStats::default(), 0); }
    let parsed: Vec<ParsedRustFile> = parse_rust_files(&rs_files).into_iter().filter_map(|r| r.ok()).collect();
    let cnt = parsed.len();
    let refs: Vec<&ParsedRustFile> = parsed.iter().collect();
    let mut stats = MetricStats::collect_rust(&refs);
    stats.collect_graph_metrics(&crate::rust_graph::build_rust_dependency_graph(&refs));
    (stats, cnt)
}

/// Collect stats from multiple paths
pub fn collect_all_stats(paths: &[String], lang: Option<Language>) -> ((MetricStats, usize), (MetricStats, usize)) {
    let (mut py, mut rs) = ((MetricStats::default(), 0), (MetricStats::default(), 0));
    for path in paths {
        let root = Path::new(path);
        if lang.is_none() || lang == Some(Language::Python) { 
            let (s, c) = collect_py_stats(root); 
            py.0.merge(s); 
            py.1 += c; 
        }
        if lang.is_none() || lang == Some(Language::Rust) { 
            let (s, c) = collect_rs_stats(root); 
            rs.0.merge(s); 
            rs.1 += c; 
        }
    }
    (py, rs)
}

/// Write a mimic configuration file
pub fn write_mimic_config(out: &Path, toml: &str, py_cnt: usize, rs_cnt: usize) {
    let content = if out.exists() { 
        merge_config_toml(out, toml, py_cnt > 0, rs_cnt > 0) 
    } else { 
        toml.to_string() 
    };
    if let Err(e) = std::fs::write(out, &content) { 
        eprintln!("Error writing to {}: {}", out.display(), e); 
        std::process::exit(1); 
    }
    eprintln!("Generated config from {} files â†’ {}", py_cnt + rs_cnt, out.display());
}

fn format_section(out: &mut String, name: &str, section: Option<&toml::Value>) {
    if let Some(v) = section {
        out.push_str(&format!("[{}]\n", name));
        if let Some(t) = v.as_table() { 
            for (k, v) in t { 
                out.push_str(&format!("{} = {}\n", k, v)); 
            } 
        }
        out.push('\n');
    }
}

/// Merge new config with existing config file
pub fn merge_config_toml(path: &Path, new: &str, upd_py: bool, upd_rs: bool) -> String {
    let (Ok(ex_str), Ok(nw)) = (std::fs::read_to_string(path), new.parse::<toml::Table>()) else { 
        return new.to_string(); 
    };
    let Ok(ex) = ex_str.parse::<toml::Table>() else { return new.to_string(); };
    let pick = |k: &str, upd: bool| if upd { nw.get(k) } else { ex.get(k) }.cloned();
    let mut m = toml::Table::new();
    for (k, upd) in [("python", upd_py), ("rust", upd_rs)] { 
        if let Some(v) = pick(k, upd) { m.insert(k.to_string(), v); } 
    }
    let shared = if upd_py && upd_rs { nw.get("shared") } else { ex.get("shared").or(nw.get("shared")) }.cloned();
    if let Some(v) = shared { m.insert("shared".to_string(), v); }
    if !(upd_py && upd_rs) && let Some(v) = ex.get("thresholds").cloned() { 
        m.insert("thresholds".to_string(), v); 
    }
    build_merged_output(&m)
}

fn build_merged_output(m: &toml::Table) -> String {
    let mut out = String::from("# Generated by kiss mimic\n# Thresholds based on 99th percentile of analyzed codebases\n\n");
    for k in ["python", "rust", "shared", "thresholds"] { 
        format_section(&mut out, k, m.get(k)); 
    }
    out
}

/// Generate TOML config from stats for each language
pub fn generate_config_toml_by_language(py: &MetricStats, rs: &MetricStats, py_n: usize, rs_n: usize) -> String {
    let mut out = String::from("# Generated by kiss mimic\n# Thresholds based on 99th percentile of analyzed codebases\n\n");
    if py_n > 0 { append_section(&mut out, "[python]", &compute_summaries(py), python_config_key); }
    if rs_n > 0 { append_section(&mut out, "[rust]", &compute_summaries(rs), rust_config_key); }
    if py_n > 0 && rs_n > 0 { append_shared_section(&mut out, &compute_summaries(py), &compute_summaries(rs)); }
    out
}

fn append_section(out: &mut String, header: &str, sums: &[PercentileSummary], key_fn: fn(&str) -> Option<&'static str>) {
    out.push_str(header); 
    out.push('\n');
    for s in sums { 
        if let Some(k) = key_fn(s.name) { 
            out.push_str(&format!("{} = {}\n", k, s.p99)); 
        } 
    }
    out.push('\n');
}

fn append_shared_section(out: &mut String, py_sums: &[PercentileSummary], rs_sums: &[PercentileSummary]) {
    out.push_str("[shared]\n");
    for py_s in py_sums {
        if let Some(k) = shared_config_key(py_s.name) {
            let rs_val = rs_sums.iter().find(|s| s.name == py_s.name).map(|s| s.p99).unwrap_or(0);
            out.push_str(&format!("{} = {}\n", k, py_s.p99.max(rs_val)));
        }
    }
}

/// Map metric name to Python-specific config key
pub fn python_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Statements per function" => Some("statements_per_function"),
        "Arguments (positional)" => Some("positional_args"),
        "Arguments (keyword-only)" => Some("keyword_only_args"),
        "Max indentation depth" => Some("max_indentation"),
        "Branches per function" => Some("branches_per_function"),
        "Local variables per function" => Some("local_variables"),
        "Methods per class" => Some("methods_per_class"),
        "Fan-out (per module)" => Some("fan_out"),
        "Fan-in (per module)" => Some("fan_in"),
        "LCOM % (per class)" => Some("lcom"),
        _ => None,
    }
}

/// Map metric name to Rust-specific config key
pub fn rust_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Statements per function" => Some("statements_per_function"),
        "Arguments (total)" => Some("arguments"),
        "Max indentation depth" => Some("max_indentation"),
        "Branches per function" => Some("branches_per_function"),
        "Local variables per function" => Some("local_variables"),
        "Methods per class" => Some("methods_per_type"),
        "Fan-out (per module)" => Some("fan_out"),
        "Fan-in (per module)" => Some("fan_in"),
        "LCOM % (per class)" => Some("lcom"),
        _ => None,
    }
}

/// Map metric name to shared config key (metrics that apply to both languages)
pub fn shared_config_key(name: &str) -> Option<&'static str> {
    match name {
        "Lines per file" => Some("lines_per_file"),
        "Classes per file" => Some("types_per_file"),
        "Imports per file" => Some("imports_per_file"),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_collect_py_stats_empty() {
        let tmp = TempDir::new().unwrap();
        let (stats, count) = collect_py_stats(tmp.path());
        assert_eq!(count, 0);
        let _ = stats;
    }

    #[test]
    fn test_collect_rs_stats_empty() {
        let tmp = TempDir::new().unwrap();
        let (stats, count) = collect_rs_stats(tmp.path());
        assert_eq!(count, 0);
        let _ = stats;
    }

    #[test]
    fn test_collect_all_stats_empty() {
        let tmp = TempDir::new().unwrap();
        let paths = vec![tmp.path().to_string_lossy().to_string()];
        let ((py, py_count), (rs, rs_count)) = collect_all_stats(&paths, None);
        assert_eq!(py_count, 0);
        assert_eq!(rs_count, 0);
        let _ = (py, rs);
    }

    #[test]
    fn test_python_config_key() {
        assert_eq!(python_config_key("Statements per function"), Some("statements_per_function"));
        assert_eq!(python_config_key("Unknown"), None);
    }

    #[test]
    fn test_rust_config_key() {
        assert_eq!(rust_config_key("Statements per function"), Some("statements_per_function"));
        assert_eq!(rust_config_key("Unknown"), None);
    }

    #[test]
    fn test_shared_config_key() {
        assert_eq!(shared_config_key("Lines per file"), Some("lines_per_file"));
        assert_eq!(shared_config_key("Unknown"), None);
    }

    #[test]
    fn test_generate_config_toml_by_language_empty() {
        let py = MetricStats::default();
        let rs = MetricStats::default();
        let toml = generate_config_toml_by_language(&py, &rs, 0, 0);
        assert!(toml.contains("Generated by kiss"));
    }

    #[test]
    fn test_build_merged_output() {
        let table = toml::Table::new();
        let out = build_merged_output(&table);
        assert!(out.contains("Generated by kiss"));
    }

    #[test]
    fn test_format_section() {
        let mut out = String::new();
        let mut table = toml::Table::new();
        table.insert("key".to_string(), toml::Value::Integer(42));
        format_section(&mut out, "test", Some(&toml::Value::Table(table)));
        assert!(out.contains("[test]"));
        assert!(out.contains("key = 42"));
    }

    #[test]
    fn test_append_section() {
        let mut out = String::new();
        let sums = vec![PercentileSummary { name: "Statements per function", count: 10, max: 50, p50: 5, p90: 10, p95: 15, p99: 20 }];
        append_section(&mut out, "[python]", &sums, python_config_key);
        assert!(out.contains("[python]"));
        assert!(out.contains("statements_per_function = 20"));
    }

    #[test]
    fn test_append_shared_section() {
        let mut out = String::new();
        let py = vec![PercentileSummary { name: "Lines per file", count: 5, max: 500, p50: 100, p90: 200, p95: 250, p99: 300 }];
        let rs = vec![PercentileSummary { name: "Lines per file", count: 5, max: 600, p50: 150, p90: 250, p95: 350, p99: 400 }];
        append_shared_section(&mut out, &py, &rs);
        assert!(out.contains("[shared]"));
        assert!(out.contains("lines_per_file = 400")); // max of 300 and 400
    }
}

